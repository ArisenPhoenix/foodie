import SQL_BASE from "./SQL_BASE";
import {
  ForeignKeyMap,
  PrimaryKey,
  Schema,
  None,
  RowEntry, 
  Messenger, 
  Value,
  Options
} from "./SQL_TYPES";
import {
  paramsIncludeAutoGenId,
} from "../HELPERS/checkAutoGenId.js"; 
import ARGS from "./postgreArgs";

export default class SQL_ROW extends SQL_BASE {
  isRow: boolean;
  rowData: {};
  rowValues: Value[];
  isIdAutoGenerated: string | false
  jsonColumns: number[]
  jsonColumnNames: string[]
  constructor(
    rowEntryData: RowEntry,
    tableName: string,
    tableSchema: Schema,  
    callAddress: string, 
    messenger: Messenger | null | false,
    primaryKey: PrimaryKey | null | undefined = null,
    foreignKeyMap: ForeignKeyMap | None = null,
    isIdAutoGenerated: string | false = false
  ) {
    super(
      tableName,
      tableSchema,
      callAddress,
      messenger,
      primaryKey,
      foreignKeyMap,
      isIdAutoGenerated
    ); 

    // New Values Added To Row Class
    this.isRow = false;
    this.rowData = rowEntryData
    this.rowValues = [];

    // Row Class Values
    this.primaryKey = primaryKey; 
    this.foreignKeyMap = foreignKeyMap; 
    this.isIdAutoGenerated = isIdAutoGenerated ? isIdAutoGenerated : this.isIdAutoGenerated
    this.jsonColumns = []
    this.jsonColumnNames = []

    // INIT
    this.construct()
    this.checkColumnNamesMatch();
    this.checkJsonColumns()
    
  } 


  checkJsonColumns = (tableSchema: Schema = this.tableSchema) => {
    tableSchema.forEach((schema, index) => {
      const {column, params} = schema
      if (params.includes(ARGS.jsonb)){
        this.jsonColumns.push(this.isIdAutoGenerated ? index -1 : index)
        this.jsonColumnNames.push(column)
      }
  })

}

  checkColumnNamesMatch = () => {
    for (let schema of this.tableSchema) {
      const { column, params } = schema;
      if (!this.rowData[column] && !this.rowData[column] == false && !paramsIncludeAutoGenId(params)) {
        throw Error(
          `The Column Name ${column} Was Not Present In The Row Data You Supplied For Table ${this.tableName}` 
        );
        
      }
    }
    this.properties
  };

  compareAllColumns = () => {
    const colNames = this.columnNames;
    const colVals = this.rowValues;
    let text = "";
    for (let i = 0; i < colNames.length; i++) {
      const col = colNames[i];
      const value = colVals[i];
      const addend = i === colNames.length - 1 ? "" : "AND";
      text += `"${col}" = '${value}' ${addend} `;
    }
    return text;
  };

  getIdByAllValuesQuery = () => {
    const allCompared = this.compareAllColumns();
    const query = `SELECT ${this.primaryKey} FROM ${this.tableName} WHERE ${allCompared}`;
    return query;
  };

  getKeys(tableSchema: Schema = this.tableSchema) {


    if (tableSchema && this.primaryKey == null) {
      tableSchema.forEach((schema) => {
        const {column, params} = schema
        this.columnNames.push(column);
        if (params.includes(ARGS.primaryKey)){
          if (this.primaryKey === null) {
            this.primaryKey = column;
          } else {
            throw new Error("A Table May Only Have Up To 1 Primary Key");
          }
        }
        

        if (params.includes(ARGS.foreignKey)){
          console.log(`ARG ${column} Is A Foreign Key`)
          this.foreignKeyColumnNames.push(column); 
        }
      });
    } 
    if (!this.primaryKey) {
      throw new Error("Your Table Must Contain A PRIMARY KEY");
    } 
  } 
 
    
  
  add = async (options: Options | undefined) => {
    
    this.adding = true
    this.returning = true
    let query = this.getAddRowQueryString();

    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query

    const response = await this.call(  
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "SQL_ROW.add"
    );
    const data = this.HANDLE_RESPONSE(response)
    this.adding = false
    this.returning = false
    return data
  };

  INSERT_VALUES = () => {
    let values = this.rowValues
    let valuesString = ` VALUES ( `
    valuesString += this.isIdAutoGenerated && this.adding ? "DEFAULT, " : ""
    valuesString += this.HANDLE_INSERT_ARRAY_DATA(values, `'`, this.jsonColumns)
    return valuesString + ") "
  }

  INSERT_COLUMNS = () => {
    let columns = this.columnNames 
    if (this.isIdAutoGenerated && this.adding){
      columns.splice(0, 0, this.primaryKey)
    }
    
    let columnsString = "( "
    columnsString += this.HANDLE_INSERT_ARRAY_DATA(columns, `"`)
    return columnsString += " )"
  }

  INSERT_STRING = () => { 
    const query = `INSERT INTO "${this.tableName}" `
    return query 
  }

  getAddRowQueryString = () => {
    let query = this.INSERT_STRING()
    query += this.INSERT_COLUMNS()
    query += this.INSERT_VALUES()
    return query
  }

  remove = async (options: Options | undefined) => {
    let query = this.getRemoveRowQueryString()
    this.returning = true
    this.deleting = true

    
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    const response = await this.call( 
      { query: query, type: "DELETE" },
      "DELETE",
      this.callAddress,
      "SQL_ROW.remove"
    );

    const data = this.HANDLE_RESPONSE(response)
    this.deleting = false
    this.returning = false
    console.log("DATA: ", data)
    return data
  }

  DELETE_ROW_STRING = () => {
    const query = `DELETE FROM ${this.tableName} `
    return query
  }

  getRemoveRowQueryString = () => {
    let query = this.DELETE_ROW_STRING() + this.Wheres(this.rowData)
    return query
  }

 
  update = async (options: Options | undefined) => {
    const primaryKeyValue = this.rowData[this.primaryKey]
    const temp = {...this.rowData}
    delete temp[this.primaryKey] 
    this.returning = true
    this.updating = true
    let query = this.SETS(temp, this.jsonColumnNames)

    query += this.Wheres({[this.primaryKey]: primaryKeyValue})

    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query

    const response = await this.call( 
      { query: query, type: "PUT" },
      "PUT",
      this.callAddress,
      "SQL_ROW.update"
    );
    const data = this.HANDLE_RESPONSE(response)
    if (data.rows && data.rows != null && data.rows.length > 0){
      this.rowData = data.rows[0]
    }
    this.returning = false
    this.updating = false
    return data
  }

  

  private extrapolateRowData() {
    if (this.rowData){
      const rowDataKeys = Object.keys(this.rowData);
      if (rowDataKeys.length > 0) {
        this.columnNames = rowDataKeys;
        this.rowValues = Object.values(this.rowData);
      
      } else if (this.rowValues) {
      }
    }
    
  }

  construct(tableSchema: Schema = this.tableSchema) {
    if (tableSchema) {
      if (this.rowData){
        this.extrapolateRowData();
        this.getKeys();  
      }
      
    }
  }

}
