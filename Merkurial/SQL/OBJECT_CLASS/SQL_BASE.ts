import FETCH from "Merkurial/API_STORAGE/APIS/FETCH";
import {
  Schema,
  ForeignKeyMap,
  PrimaryKey,
  Messenger,
  TABLE_RESPONSE,
  ColumnInput,
  None,
  Row,
  Rows,
  Value,
  RowEntry,
  Options,
  ColumnName,
  ColumnEntry
} from "./SQL_TYPES";



import {
  getForeignKey,
  getPrimaryKey,
  paramsIncludeAutoGenId,
} from "../HELPERS/checkAutoGenId";
import SQL_ROW from "./SQL_ROW";

import ARGS from "./postgreArgs"

const { numeric, jsonb } = ARGS

type query = {query: string, type?: string | undefined}
type Properties = {}

export default class SQL_BASE {
  // Must Be Supplied
  tableName: string;
  tableSchema: Schema;
  callAddress: string;
  isPopulated: true | None;
  
  // Optionally Supplied
  messenger: Messenger | None;

  // Wiil Be Extrapolated From Schema
  primaryKey: PrimaryKey;
  columnNames: string[];
  foreignKeyColumnNames: string[];
  isIdAutoGenerated: string | false;
  containsArray: boolean;

  // Can Be Extrapolated Elsewhere
  foreignKeyMap: ForeignKeyMap | None;
  allRows: Row[] | Array<Row>
  sqlRows: SQL_ROW[]

  returning: boolean
  deleting: boolean
  updating: boolean
  adding: boolean
  lastQuery: string | undefined

  constructor(
    tableName: string,
    tableSchema: Schema,
    callAddress: string,
    messenger: Messenger | None,
    primaryKey: PrimaryKey | null = null,
    foreignKeyMap: ForeignKeyMap | null | false = false,
    isIdAutoGenerated: string | false = false
    
  ) {
    this.tableName = tableName; 
    this.tableSchema = tableSchema;
    this.callAddress = callAddress;
    this.messenger = messenger;
    this.isPopulated = false;
    this.primaryKey = primaryKey;
    this.foreignKeyMap = foreignKeyMap == null ? {} : foreignKeyMap
    this.columnNames = [];
    this.foreignKeyColumnNames = [];
    this.isIdAutoGenerated = isIdAutoGenerated
    this.allRows = []
    this.containsArray = false
    this.returning = false
    this.deleting = false
    this.updating = false
    this.adding = false
    this.construct();
    this.lastQuery = undefined
    
  }

  construct() {
    if (this.tableSchema.length > 0) {
      this.extrapolateData(this.tableSchema);
    }
  }

  properties = (): Properties => {
    const props = {
      tableName: this.tableName,
      tableSchema: this.tableSchema,
      callAddress: this.callAddress,
      primaryKey: this.primaryKey,
      foreignKeyMap: this.foreignKeyMap,
      columnNames: this.columnNames,
      foreignKeyColumnNames: this.foreignKeyColumnNames,
    }
    return props
  };

  private extrapolateData = (tableSchema: Schema) => {
    if (
      !this.primaryKey ||
      this.primaryKey == null ||
      !this.columnNames ||
      this.columnNames == null ||
      this.columnNames.length === 0 ||
      !this.foreignKeyColumnNames ||
      this.foreignKeyColumnNames == null || 
      this.foreignKeyColumnNames.length === 0 ||  
      !this.isIdAutoGenerated
    ) {
      tableSchema.forEach((columnData) => {
        // console.log(column)
        const {column, params} = columnData
        this.columnNames.push(column);
        const primaryKey = getPrimaryKey(params)
        const foreignKey = getForeignKey(params)
        if (JSON.stringify(params).includes("[]")){
          this.containsArray = true
        }
        if (foreignKey && primaryKey){
          throw Error("There Cannot Be Both A Primary Key And A Foreign Key Assigned To A Column")
        } else {
          if (this.primaryKey == null && primaryKey){
            this.primaryKey = column
            this.isIdAutoGenerated = paramsIncludeAutoGenId(params)
          } 
          else if (this.primaryKey && primaryKey) {
            throw new Error("A Table May Only Have Up To 1 Primary Key");
          } 
          if (foreignKey){
            this.foreignKeyColumnNames.push(column);
            this.foreignKeyColumnNames = new Array(...new Set(this.foreignKeyColumnNames))
            this.foreignKeyMap[column] = params;
          }
        }
        if (!this.primaryKey) {
          throw new Error("Your Table Must Contain A PRIMARY KEY");
        }
        
      });
    }
  };

  compareAllColumnInputs = (arr: ColumnInput[]) => {
    let colNames = [];
    let colVals = [];
    for (let i = 0; i < arr.length; i++) {
      const [key, value] = Object.entries(arr[i]);
      colNames.push(key);
      colVals.push(value);
    }

    let text = "";
    for (let i = 0; i < colNames.length; i++) {
      const col = colNames[i];
      const value = colVals[i];
      const addend = i === colNames.length - 1 ? "" : "AND";
      text += `"${col}" = '${value}' ${addend} `;
    }
    return text;
  };

  HANDLE_SUPPLEMENTARY = (initial_query: string, options: Options) => {
    let query = initial_query
    if (options.groupBy && typeof options.groupBy === "string") {
      query += ` GROUP BY "${options.groupBy}"`
    }
    if (options.orderBy && typeof options.orderBy === "string"){
      query += ` ORDER BY "${options.orderBy}"`
    }
    if (options.limit && typeof options.limit === "number"){
      query += ` LIMIT ${options.limit}`
    } if (options.returning && typeof options.returning === "string"){
      this.returning = true
      query += ` RETURNING ${options.returning}`
    }
    return query

  }


  findRowByColumnsAndValues = async (arr: ColumnInput[], callAddress=this.callAddress, options: Options | undefined) => {

    let query = this.compareAllColumnInputs(arr);
    query = this.HANDLE_SUPPLEMENTARY(query, options)
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      callAddress,
      "findRowByColumnsAndValues"
    );
    return response;
  };

  call = async (
    query: query,
    method: string,
    address: string,
    callingFunction: string | null | undefined = null
  ) => {
    const response = await FETCH(
      address,
      method,
      { query: query.query, type: query.type },
      callingFunction
    );
    
    if (response.ok) {
      this.lastQuery = query.query
      this.isPopulated = method !== "DELETE" ? true : false;
      if (this.messenger != null) {
        response.message &&
          this.messenger &&
          this.messenger(`Table ${this.tableName} ${response.message}`);
          
      }
      return response;
    }
  };

  

  query = async (
    query: query,
    method: string = "POST",
    callAddress: string = this.callAddress,
    callingFunction: string = "SQL_BASE.query"
  ) => {
    const queryData = {query: query.query, type: query.type}
    const res = await this.call(
      queryData,
      method,
      callAddress,
      callingFunction
    );
    this.HANDLE_RESPONSE(res)

    return res;
  };


  IS_JSON = (potentialJsonString: string) => {
    try {
      return JSON.parse(potentialJsonString)
      
    } catch (err) {
      return false
    }
  }



    
  Where = (columnName: ColumnName, value: Value) => {
    let val = value;
    if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
      val = this.HANDLE_INSERT_NUMBER_OR_STRING(val, `'`)
    } else if (Array.isArray(val)){
      val = this.HANDLE_ARRAY_COLUMN_VALUES(val)
    } 
    return `"${columnName}" = ${val} `;
  };

  TableWhere = (columnName: ColumnName, tableName: string, value: Value) => {
    let val = value;
    if (typeof val == "string") {
      val = `'${value}'`;
    }
    return `"${columnName}" = '${tableName}'.${val}`;
  };

  Wheres = (args: ColumnInput) => {
    let query = "WHERE ";
    const entries = Object.entries(args);
    entries.forEach((entry, index) => {
      const addend = index === entries.length - 1 ? "" : "AND ";
      query += this.Where(entry[0], entry[1]) + addend;
    });
    return query;
  };

  SET_STRING = () => {
    const setString = `UPDATE ${this.tableName} SET `
    return setString
  }

  SET = (columnName: ColumnName, value: any, isJsonB: boolean) => {
    if (isJsonB){
      const set = `${columnName} = ${this.HANDLE_INSERT_JSON_B(value)}`
      return set
    } else if (Array.isArray(value)){
      const set = `${columnName} = ${this.HANDLE_INSERT_ARRAY(value)} `
      return set
    } 
    const set = `${columnName} = ${this.HANDLE_INSERT_NUMBER_OR_STRING(value, `'`)} `
    return set
  }

  SETS = (itemsToSet: RowEntry, jsonColumnNames: string[] | undefined) => {
    let setQuery = this.SET_STRING() 
    const entries = Object.entries(itemsToSet)
    entries.forEach((entry, index) => {
      const isJsonB = jsonColumnNames.includes(entry[0])
      const addend = index === entries.length - 1 ? "" : ", ";
      setQuery += this.SET(entry[0], entry[1], isJsonB) + addend;
    })
    return setQuery
  }

  HANDLE_INSERT_NUMBER_OR_STRING = (value: Value, quote: string) => {
    if (typeof value == "string"){
      return `${quote}${value}${quote}`
    } else if (typeof value == "number"){
      return value
    } else {
      return value
    }
  }

  HANDLE_INSERT_ARRAY = (array: Array<string|number>) => {
    const newArray = array.map((item) => {
      if (Array.isArray(item)){
        return this.HANDLE_INSERT_ARRAY(item)
      } else {
        return this.HANDLE_INSERT_NUMBER_OR_STRING(item, `'`)
      }
    })

    let sqlArray = "'{"
    sqlArray += newArray.join(",")
    sqlArray += "}'"
    return sqlArray
  }

  HANDLE_INSERT_JSON_B = (object: {}) => {
    return `'${JSON.stringify(object)}'::jsonb`
  }


  HANDLE_INSERT_ARRAY_DATA = (array: any[], quote: string, jsonColumns: number[] | undefined = undefined) => {
    let string = ""
    array.forEach((value, index) => {
      if (jsonColumns && Array.isArray(jsonColumns) && jsonColumns.includes(index)){
        string += this.HANDLE_INSERT_JSON_B(value)
      }
      
      else if (Array.isArray(value)){
        string += this.HANDLE_INSERT_ARRAY(value)
      } else {
        string += this.HANDLE_INSERT_NUMBER_OR_STRING(value, quote)
      }
      if (index !== array.length - 1){
        string += ', '
      }
    })
    return string
  }
  
  HANDLE_ARRAY_COLUMN_VALUES = (rowColumnValue: Value | Value[]) => {
    if (Array.isArray(rowColumnValue)){
      const values = rowColumnValue.map((value: any) => {
        if ( value && typeof value === "string" && !Number.isNaN(Number(value))){
          return Number(value)
        } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean"){
          return this.HANDLE_INSERT_NUMBER_OR_STRING(value, `'`)
        } else {
          if (value){
            return value
          } else {
            throw Error(`Cannot Interpret Column Value Of Type ${typeof value}`)
          }
        }
      })
      return values
    } else {
      return rowColumnValue
    }
  } 

  HANDLE_ROWS = (rows: Rows): any => {
    const ROWS_FINAL = rows.map((row: Row) => {
      let newRow = row
      if (this.containsArray){
        for (const column in row){
          const rowColumnValue = row[column]
          const UpdatedRowValue = this.HANDLE_ARRAY_COLUMN_VALUES(rowColumnValue)
          newRow[column] = UpdatedRowValue
        }
      }  
      
      return newRow
  })

  
  return ROWS_FINAL
  
}

  protected HANDLE_RESPONSE = ( 
    response: any,
    deleted: boolean = false
  ): TABLE_RESPONSE => {
    if (response?.response && !response?.message) {
      if (!deleted) {
        const rows: Rows = response.response.rows;
        if ((Array.isArray(rows) && rows.length == 0) || !rows || rows == null){
          this.isPopulated = false
        }
        if (Array.isArray(rows) && rows.length > 0) {
          const updatedRows = this.HANDLE_ROWS(rows)
          this.tableSchema.forEach((schema, index) => {
            const {column, params} = schema
            updatedRows.forEach((row: Row, rowIndex: number) => {
              if (params.includes(numeric)){
                  updatedRows[rowIndex][column] = Number(updatedRows[rowIndex][column])
              } 
            })
          })
          this.allRows = [...updatedRows]
          
          return { 
            rows: this.allRows,
            ok: response.ok,
            err: false,
            message: response.message,
            isPopulated: this.isPopulated,
          };
        } else {

          return {
            ok: false,
            err: response.message,
            rows: this.allRows,
            isPopulated: this.isPopulated,
            message: response.message
          }
        }

      } else {
        return {
          ok: false,
          err: response.message,
          rows: this.allRows,
          isPopulated: this.isPopulated,
          message: response.message,
        };
      }
    } else if (response?.message) {
      return {
        ok: false,
        err: response.message,
        message: response.message,
        rows: this.allRows,
        isPopulated: this.isPopulated,
      };
    } else {
      return {
        ...response,
        message: "Something Went Wrong",
        rows: this.allRows,
      };
    }
  };
}
