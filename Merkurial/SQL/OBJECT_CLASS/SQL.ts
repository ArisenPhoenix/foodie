import TABLE from "./SQL_TABLE";
import SQL_ROW from "./SQL_ROW"
import { Row, Messenger, Schema, Value, Params, ColumnName, RowEntry, None, Options, ForeignKeyMap } from "./SQL_TYPES";
import SQL_COLUMN from "./SQL_COLUMN"


class SQL_TABLE extends TABLE {
    isRow: boolean

    constructor( 
        tableName: string,
        callAddress: string,
        tableSchema: Schema | null,
        messenger: Messenger | None,
        foreignKeyMap: ForeignKeyMap | null = null
    ) {
        super(tableName, callAddress, tableSchema, messenger);
    }


    newRow = (
      rowEntryData: RowEntry, 
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger) => {
      if (this.primaryKey && rowEntryData != null && rowEntryData){
          const row = new SQL_ROW(
              rowEntryData,
              this.tableName,
              this.tableSchema, 
              callAddress,
              messenger, 
              this.primaryKey, 
              this.foreignKeyMap,
              this.isIdAutoGenerated
              )
          return row
      } else {
        throw Error("All The Required Data Was Not There")
      }
    }

    handleRowResponss = (rowRes) => {
      if (rowRes.rows && rowRes.rows.length > 0){
        return rowRes.rows
      } else {
        return false
      }
    }

 
    addRow = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.adding = true
        this.returning = true
        const row = this.newRow(rowEntryData, callAddress, messenger)
        const rowRes = await row.add(options)
        if (Array.isArray(rowRes.rows) && rowRes.rows.length > 0){
          this.allRows = [...this.allRows.map(row => row), rowRes.rows[0]]
        }
        return this.allRows
      }


    getRowMatch = (row: RowEntry) => {
      const ID = this.primaryKey
      if (!Array.isArray(row) && typeof row == "object") {
        const modifiedRow = row
        const matchIndex = this.allRows.findIndex((row, index) => {
          return row[ID] == modifiedRow[ID]
        })
        return matchIndex

      }
      return false
    }

    deleteRow = async (
      rowEntryData: Row | RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.deleting = true
        this.returning = true
        const matchIndex = this.getRowMatch(rowEntryData)
        if (typeof matchIndex == "number" && matchIndex > -1){
          const row = this.newRow(rowEntryData, callAddress, messenger)
          const rowRes = await row.remove(options)
          const deleteSuccess = rowRes.rows[0][this.primaryKey] === rowEntryData[this.primaryKey]
          if (deleteSuccess){
            const temp = this.allRows.slice()
            temp.splice(matchIndex, 1)
            if (temp.length == 0){
              this.allRows = []
            } else {
              this.allRows = [...temp]
              
            }
            return this.allRows
          }
        }
        return false
      }

    deleteRowByAnyColumns = async (
      rowEntryData: Row | RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger,
    ) => {
      this.deleting = true
      this.returning = true
      const newRow = this.newRow(rowEntryData, callAddress, messenger)
      const rowDelResponse = await newRow.remove(options)
      if (rowDelResponse.rows.length > 0){
        const rowData = rowDelResponse.rows[0]
        const matchIndex = this.getRowMatch(rowData)
        const temp = this.allRows.slice()
        if (typeof matchIndex === "number" && matchIndex > -1) {
          temp.splice(matchIndex, 1)
          this.allRows = [...temp]
          return this.allRows
        } else {
          // console.log("Match Failed")
          return false
        }
      } else {
        // console.log("Deletion of Row Failed")
        return false
      } 
      
    }
    
    updateRowByAnyColumns = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.updating = true
        this.returning = true
        const matchIndex = this.getRowMatch(rowEntryData)
        if (typeof matchIndex === "number" && matchIndex > -1){
        const newRow = this.newRow(rowEntryData, callAddress, messenger)
        const rowUpdateRes = await newRow.update(options)
        if (rowUpdateRes.rows?.length > 0){
          const temp = this.allRows.slice()
          const rowToUpdate = temp[matchIndex]
          const finalRowData = {...rowToUpdate, ...rowEntryData} 
          this.allRows = [...temp]
          this.allRows.splice(matchIndex, 1, finalRowData)
          this.allRows = [...this.allRows]
          return this.allRows
        } else {
          console.log("Update By Any Was Unsuccessful")
          return false
        }
      } else {
        console.log("The ID Provided Did Not Match Any Row Ids")
        return false
        
      }
      
    }

    updateRow = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.updating = true
        this.returning = true
        const matchIndex = this.getRowMatch(rowEntryData)

        if (typeof matchIndex == "number" && matchIndex > -1){
          const row = this.newRow(rowEntryData, callAddress, messenger)
          const rowRes = await row.update(options)
          const updateSuccess = JSON.stringify(rowRes.rows[0]) == JSON.stringify(rowEntryData)
          if (updateSuccess){
            const temp = this.allRows.slice()
            temp[matchIndex] = rowEntryData
            this.allRows = [...temp]
            return this.allRows
          }
        }
        return false
      }

    addColumn = (columnName: ColumnName, params: Params, defaultValue: Value) => {
      const column = new SQL_COLUMN(this.tableName, columnName, params)
      return column
      }
  }

export default SQL_TABLE






