import CONVERT_CONSTRUCTOR_TO_CREATE_TABLE_IF_NOT_EXISTS from "../HELPERS/convertObjectToQuery.js";
import SQL_BASE from "./SQL_BASE";
import SQL_ROW from "./SQL_ROW.ts";

import {
  Key,
  Schema,
  ColumnInput,
  Messenger,
  ForeignKeyValuePair,
  ForeignKeyMap,
  Options,
  PrimaryKey
} from "./SQL_TYPES.ts";

export default class TABLE extends SQL_BASE {
  hasTable: boolean;
  sqlRows: SQL_ROW[]
  isIdAutoGenerated: string | false;

  constructor(
    tableName: string,
    callAddress: string, 
    tableSchema: Schema | null,
    messenger: Messenger | null | false,
    primaryKey: PrimaryKey | null = null,
    foreignKeyMap: ForeignKeyMap | null = null
  ) {
    super(tableName, tableSchema, callAddress, messenger, primaryKey, foreignKeyMap);
    this.sqlRows = []
     
  }

  CREATE_TABLE = async (foreignKeyMap: ForeignKeyMap = null) => {
    const query = CONVERT_CONSTRUCTOR_TO_CREATE_TABLE_IF_NOT_EXISTS(
      this.tableName,
      this.tableSchema,
      foreignKeyMap
    );

    console.log("CREATE_TABLE QUERY: ", query)

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL_TABLE.CREATE_TABLE"
    );

    return { ...response, hasTable: this.hasTable };
  };

  HAS_TABLE = async () => {
    if (!this.hasTable) {
      const tableData = await this.GET_TABLE();
      this.hasTable = tableData.isPopulated
      return this.hasTable
    } else {
      return this.hasTable;
    }
  };

  DELETE_TABLE = async () => {
    const queryText = `DROP TABLE ${this.tableName}`;
    const response = await this.call(
      { query: queryText },
      "DELETE",
      this.callAddress,
      "SQL.DELETE_TABLE"
    );
    const data = this.HANDLE_RESPONSE(response, true);
    if (data.ok) {
      return data;
    }
    return { ...response, hasTable: this.hasTable };
  };

  GET_TABLE = async () => {
    const query = `SELECT * FROM ${this.tableName}`;
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "TABLE.GET_TABLE"
    );
    const data = this.HANDLE_RESPONSE(response);
    return data;
  };

  INITIALIZE_TABLE = async () => {
    const query = `SELECT * FROM ${this.tableName} LIMIT 1`;
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "TABLE.INITIALIZE_TABLE"
    );
    // const data = this.HANDLE_RESPONSE(response);
    const data = response?.response?.rows
    return data;
  };

  /**
   * @param columnVals required - The values for the entry | must match schema value structure in length and type
   * @param callAddress optional - the address for making api calls to defaults to the same as the Table Class
   * @param messager optional - a call back function with a single parameter for returning a message back, defaults to the same as the Table Class
   * @returns a new table column class with it's own various methods
   */

  FindRowById = async (id: Key) => {
    const rowId =
      typeof id === "string" ? `'${id}'` : typeof id === "number" ? id : null;
    if (!rowId && rowId != 0) {
      throw new TypeError("That Id Is Not Of Type Number Nor String");
    }
    const query = `SELECT * FROM ${this.tableName} WHERE "${this.primaryKey}" = ${rowId}`;
    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "TABLE.FindRowById"
    );
    const data = this.HANDLE_RESPONSE(response);
    if (data.ok) {
      if (Array.isArray(data.rows) && data.rows.length > 0) {
        const rows = this.HANDLE_ROWS(data.rows)
        this.sqlRows = []
        for (let row of rows){
          
          this.sqlRows.push(new SQL_ROW(row, this.tableName, this.tableSchema, this.callAddress, this.messenger, this.primaryKey, this.foreignKeyMap, this.isIdAutoGenerated))
        }
        return data;
      } else {
        return null;
      }
    }
  };

  checkArgs = (args: ColumnInput) => {
    const argArr = Object.keys(args);
    argArr.forEach((argument, index) => {
      if (!this.tableSchema[argument]) {
        throw new Error(
          `You entered a column that does not exist within the current schema. at index ${index}`
        );
      }
    });
    return true;
  };



  SELECT_ALL = () => {
    return "SELECT * ";
  };

  FROM_TABLE = () => {
    return `FROM ${this.tableName} `;
  };

  SELECT_ALL_BY_FOREIGN_KEY_MATCH = async (
    foreignKeyValuePair: ForeignKeyValuePair, options: Options | undefined
  ) => {
    const selectedFk = Object.keys(foreignKeyValuePair)[0];
    const value = foreignKeyValuePair[selectedFk];

    let query = this.SELECT_ALL() + this.FROM_TABLE();
    query += "WHERE " + this.Where(selectedFk, value);
    
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query

    const res = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "Row.FindRowById"
    );

    const data = this.HANDLE_RESPONSE(res);
    return data;
    
  };

  selectedColumns = (args: ColumnInput) => {
    let query = "";
    const entries = Object.entries(args);
    entries.forEach((entry, index) => {
      const [column, value] = entry;
      if (!this.tableSchema[column]) {
        throw new Error(
          `Column ${column} does not exist on table ${this.tableName}. `
        );
      }
      const addend = index === entries.length - 1 ? "" : ", ";
      query += `"${column}${addend}"`;
    });
    return query;
  };

  SelectAllByValues = async (object: ColumnInput, options: Options | undefined) => {

    const WHERES = this.Wheres(object);
    let query = `SELECT * FROM ${this.tableName} ${WHERES}`;
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    console.log("Final Query: ", query)

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL.SelectAllByValues"
    );
    const data = this.HANDLE_RESPONSE(response);
    return data;
  };

  SelectBySelectColumnsAndValues = async (object: ColumnInput, options: Options | undefined) => {
    const WHERES = this.Wheres(object);
    const Selected = this.selectedColumns(object);
    let query = `SELECT ${Selected} FROM ${this.tableName} ${WHERES}`;
    query = options ?  this.HANDLE_SUPPLEMENTARY(query, options) : query

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL.SelectBySelectColumnsAndValues"
    );
    const data = this.HANDLE_RESPONSE(response);
    return data;
  };

  UPDATE_TABLE = async(query: string | undefined = this.lastQuery) => {
    if (typeof this.lastQuery == "string") {
      const res = await this.call({query: query ? query : this.lastQuery, type: "POST"}, "POST", this.callAddress, "SQL_TABLE.UPDATE_TABLE")
      const data = this.HANDLE_RESPONSE(res)
      return data
    }
  }
}
